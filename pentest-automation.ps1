# Script de Automação de Testes de Penetração
# Utiliza OWASP ZAP para realizar testes automatizados de segurança
# Versão 2.0 - Foco em Autenticação e Autorização

# Configurações
$targetUrl = "http://localhost:19006" # URL do aplicativo em execução (ajuste conforme necessário)
$reportPath = "./security-reports/pentest"
$zapPath = "$env:ProgramFiles\OWASP\Zed Attack Proxy"
$timestamp = Get-Date -Format "yyyy-MM-dd-HHmmss"
$authReportFile = "$reportPath/auth-pentest-report-$timestamp.txt"

# Cria diretório para relatórios se não existir
if (-not (Test-Path $reportPath)) {
    New-Item -Path $reportPath -ItemType Directory -Force | Out-Null
}

# Verifica se o OWASP ZAP está instalado
if (-not (Test-Path "$zapPath\zap.bat")) {
    Write-Host "OWASP ZAP não encontrado. Por favor, instale-o de https://www.zaproxy.org/download/" -ForegroundColor Red
    Write-Host "Após a instalação, ajuste o caminho no script se necessário." -ForegroundColor Yellow
    exit 1
}

# Função para executar testes específicos
function Run-SecurityTest {
    param (
        [string]$testName,
        [string]$testCommand
    )
    
    Write-Host "Executando teste: $testName" -ForegroundColor Cyan
    Invoke-Expression $testCommand
    Write-Host "Teste concluído: $testName" -ForegroundColor Green
}

# Inicia o ZAP em modo daemon
Write-Host "Iniciando OWASP ZAP..." -ForegroundColor Yellow
Start-Process -FilePath "$zapPath\zap.bat" -ArgumentList "-daemon -config api.disablekey=true -port 8090" -WindowStyle Hidden

# Aguarda o ZAP iniciar
Start-Sleep -Seconds 10

# Testes de segurança automatizados
Write-Host "Iniciando testes de penetração automatizados..." -ForegroundColor Green

# 1. Spider (Crawling do site)
Run-SecurityTest "Spider Scan" "curl -s 'http://localhost:8090/JSON/spider/action/scan/?url=$targetUrl&recurse=true&inScopeOnly=false&contextName=&subtreeOnly=false' > $reportPath\spider-results.json"

# Aguarda o Spider terminar
Start-Sleep -Seconds 30

# 2. Active Scan (Procura por vulnerabilidades)
Run-SecurityTest "Active Scan" "curl -s 'http://localhost:8090/JSON/ascan/action/scan/?url=$targetUrl&recurse=true&inScopeOnly=false&scanPolicyName=&method=&postData=' > $reportPath\active-scan-results.json"

# 3. Testes específicos de autenticação e autorização
Write-Host "Iniciando testes específicos de autenticação e autorização..." -ForegroundColor Yellow

# Inicializa o arquivo de relatório de autenticação
"# Relatório de Testes de Autenticação e Autorização - Açucaradas Encomendas`n" | Out-File -FilePath $authReportFile
"Data: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")`n" | Add-Content -Path $authReportFile
"URL do Site: $targetUrl`n" | Add-Content -Path $authReportFile
"## Resultados dos Testes`n" | Add-Content -Path $authReportFile

# Função para registrar resultados de autenticação
function Write-AuthResult {
    param (
        [string]$testName,
        [string]$status,
        [string]$details
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $result = "[$timestamp] $testName - Status: $status"
    if ($details) {
        $result += "`nDetalhes: $details"
    }
    $result += "`n"
    
    Add-Content -Path $authReportFile -Value $result
    
    if ($status -eq "FALHA") {
        Write-Host $result -ForegroundColor Red
    } elseif ($status -eq "ALERTA") {
        Write-Host $result -ForegroundColor Yellow
    } else {
        Write-Host $result -ForegroundColor Green
    }
}

# Aguarda o Active Scan terminar (pode demorar bastante)
Start-Sleep -Seconds 120

# Testes específicos de autenticação

# Teste 1: Verificação de Headers de Segurança
Write-Host "Executando teste de Headers de Segurança..." -ForegroundColor Cyan
try {
    $response = Invoke-WebRequest -Uri "$targetUrl/wp-admin/admin-ajax.php" -UseBasicParsing
    $headers = $response.Headers
    
    $securityHeaders = @{
        "X-Frame-Options" = $false
        "X-Content-Type-Options" = $false
        "X-XSS-Protection" = $false
        "Content-Security-Policy" = $false
        "Strict-Transport-Security" = $false
        "Referrer-Policy" = $false
    }
    
    $missingHeaders = @()
    $presentHeaders = @()
    
    foreach ($header in $securityHeaders.Keys) {
        if ($headers.ContainsKey($header)) {
            $securityHeaders[$header] = $true
            $presentHeaders += "$header: $($headers[$header])"
        } else {
            $missingHeaders += $header
        }
    }
    
    $details = ""
    if ($presentHeaders.Count -gt 0) {
        $details += "Headers presentes:`n" + ($presentHeaders -join "`n") + "`n"
    }
    if ($missingHeaders.Count -gt 0) {
        $details += "Headers ausentes:`n" + ($missingHeaders -join "`n")
    }
    
    if ($missingHeaders.Count -eq 0) {
        Write-AuthResult "Headers de Segurança" "SUCESSO" $details
    } elseif ($missingHeaders.Count -lt 3) {
        Write-AuthResult "Headers de Segurança" "ALERTA" $details
    } else {
        Write-AuthResult "Headers de Segurança" "FALHA" $details
    }
} catch {
    Write-AuthResult "Headers de Segurança" "ERRO" "Falha ao acessar o site: $_"
}

# Teste 2: Teste de Força Bruta em Login
Write-Host "Executando teste de proteção contra força bruta..." -ForegroundColor Cyan
try {
    $loginUrl = "$targetUrl/wp-admin/admin-ajax.php"
    $commonPasswords = @("123456", "password", "admin123", "qwerty", "letmein", "welcome", "test123")
    $username = "admin"
    $failedAttempts = 0
    $blockedAfterAttempts = $false
    $responseTimesMs = @()
    $responseContents = @()
    
    # Obtém um nonce válido para o primeiro teste (para passar pela validação inicial)
    try {
        $loginPage = Invoke-WebRequest -Uri "$targetUrl/login" -UseBasicParsing
        $nonceMatch = [regex]::Match($loginPage.Content, 'name="acucaradas-login-nonce"\s+value="([^"]+)"')
        $nonce = if ($nonceMatch.Success) { $nonceMatch.Groups[1].Value } else { "invalid_nonce" }
    } catch {
        $nonce = "invalid_nonce"
    }
    
    foreach ($password in $commonPasswords) {
        $params = @{
            action = "acucaradas_login"
            username = $username
            password = $password
            security = $nonce
        }
        
        $startTime = Get-Date
        
        try {
            $response = Invoke-WebRequest -Uri $loginUrl -Method POST -Body $params -UseBasicParsing
            $endTime = Get-Date
            $responseTime = ($endTime - $startTime).TotalMilliseconds
            $responseTimesMs += $responseTime
            $responseContents += $response.Content
            $failedAttempts++
            
            # Verifica se foi bloqueado após várias tentativas
            if ($response.Content -match "bloqueado|blocked|muitas tentativas|too many attempts|limite excedido|rate limit|captcha") {
                $blockedAfterAttempts = $true
                break
            }
        } catch {
            $endTime = Get-Date
            $responseTime = ($endTime - $startTime).TotalMilliseconds
            $responseTimesMs += $responseTime
            
            # Se receber um erro 403, 429 ou 503, pode indicar bloqueio
            if ($_.Exception.Response -and 
                ($_.Exception.Response.StatusCode -eq 403 -or 
                 $_.Exception.Response.StatusCode -eq 429 -or 
                 $_.Exception.Response.StatusCode -eq 503)) {
                $blockedAfterAttempts = $true
                $responseContents += "Status code: $($_.Exception.Response.StatusCode)"
                break
            }
            $failedAttempts++
            $responseContents += $_.Exception.Message
        }
        
        # Pequena pausa para não sobrecarregar o servidor
        Start-Sleep -Milliseconds 800
    }
    
    # Analisa os tempos de resposta para detectar throttling
    $throttlingDetected = $false
    if ($responseTimesMs.Count -gt 2) {
        $firstResponseTime = $responseTimesMs[0]
        $lastResponseTime = $responseTimesMs[$responseTimesMs.Count - 1]
        
        # Se o último tempo de resposta for significativamente maior que o primeiro (2x ou mais)
        if ($lastResponseTime -gt ($firstResponseTime * 2)) {
            $throttlingDetected = $true
        }
    }
    
    $details = "Tentativas realizadas: $failedAttempts`n"
    $details += "Tempos de resposta (ms): $($responseTimesMs -join ', ')`n"
    
    if ($blockedAfterAttempts) {
        Write-AuthResult "Proteção contra Força Bruta" "SUCESSO" "O sistema bloqueou após $failedAttempts tentativas.`n$details"
    } elseif ($throttlingDetected) {
        Write-AuthResult "Proteção contra Força Bruta" "ALERTA" "O sistema não bloqueou completamente, mas há indícios de throttling (aumento do tempo de resposta).`n$details"
    } else {
        Write-AuthResult "Proteção contra Força Bruta" "FALHA" "O sistema não bloqueou nem reduziu a velocidade após $failedAttempts tentativas.`n$details"
    }
} catch {
    Write-AuthResult "Proteção contra Força Bruta" "ERRO" "Falha ao testar proteção contra força bruta: $_"
}

# Teste 3: Verificação de CSRF Protection
Write-Host "Executando teste de proteção CSRF..." -ForegroundColor Cyan
try {
    # Tenta acessar a página de login
    $loginPage = Invoke-WebRequest -Uri "$targetUrl/login" -UseBasicParsing -ErrorAction SilentlyContinue
    
    if ($null -eq $loginPage -or $loginPage.StatusCode -ne 200) {
        # Tenta acessar a página de login do WordPress como alternativa
        $loginPage = Invoke-WebRequest -Uri "$targetUrl/wp-login.php" -UseBasicParsing -ErrorAction SilentlyContinue
    }
    
    if ($null -eq $loginPage -or $loginPage.StatusCode -ne 200) {
        # Tenta acessar qualquer formulário que possa conter proteção CSRF
        $loginPage = Invoke-WebRequest -Uri "$targetUrl" -UseBasicParsing
    }
    
    # Verifica se há campos de nonce/token CSRF no conteúdo
    $hasNonceField = $loginPage.Content -match "nonce|security|token|csrf"
    $hasNonceInput = $loginPage.Content -match '<input[^>]*name=["\'](?:_wpnonce|nonce|security|csrf_token|token)["\'][^>]*>'
    
    # Verifica se há cabeçalhos relacionados a CSRF
    $hasCSRFHeaders = $false
    if ($loginPage.Headers.ContainsKey("X-CSRF-Token") -or 
        $loginPage.Headers.ContainsKey("X-XSRF-Token") -or 
        $loginPage.Headers.ContainsKey("X-Frame-Options")) {
        $hasCSRFHeaders = $true
    }
    
    $details = ""
    if ($hasNonceInput) {
        $details += "Encontrado campo de input para token CSRF no HTML.`n"
    }
    if ($hasNonceField) {
        $details += "Encontradas referências a tokens CSRF no conteúdo da página.`n"
    }
    if ($hasCSRFHeaders) {
        $details += "Encontrados cabeçalhos relacionados a proteção CSRF.`n"
    }
    
    # Tenta fazer uma requisição sem token para verificar se é rejeitada
    try {
        $params = @{
            action = "acucaradas_login"
            username = "test_user"
            password = "test_password"
            # Intencionalmente não incluímos o token de segurança
        }
        
        $response = Invoke-WebRequest -Uri "$targetUrl/wp-admin/admin-ajax.php" -Method POST -Body $params -UseBasicParsing
        
        # Se a requisição for bem-sucedida sem token, pode indicar falta de proteção CSRF
        if ($response.Content -match "erro|invalid|falha|security|nonce") {
            $details += "Requisição sem token CSRF foi rejeitada corretamente.`n"
            $csrfProtectionWorking = $true
        } else {
            $details += "ALERTA: Requisição sem token CSRF foi aceita!`n"
            $csrfProtectionWorking = $false
        }
    } catch {
        # Se receber erro 400 ou 403, provavelmente a proteção CSRF está funcionando
        if ($_.Exception.Response -and 
            ($_.Exception.Response.StatusCode -eq 400 -or 
             $_.Exception.Response.StatusCode -eq 403)) {
            $details += "Requisição sem token CSRF foi rejeitada com código de status $($_.Exception.Response.StatusCode).`n"
            $csrfProtectionWorking = $true
        } else {
            $details += "Erro ao testar requisição sem token: $($_.Exception.Message)`n"
        }
    }
    
    if (($hasNonceField -or $hasNonceInput -or $hasCSRFHeaders) -and $csrfProtectionWorking) {
        Write-AuthResult "Proteção CSRF" "SUCESSO" $details
    } elseif ($hasNonceField -or $hasNonceInput -or $hasCSRFHeaders) {
        Write-AuthResult "Proteção CSRF" "ALERTA" "Tokens CSRF encontrados, mas a validação pode não estar funcionando corretamente.`n$details"
    } else {
        Write-AuthResult "Proteção CSRF" "FALHA" "Não foi encontrada proteção CSRF adequada.`n$details"
    }
} catch {
    Write-AuthResult "Proteção CSRF" "ERRO" "Falha ao verificar proteção CSRF: $_"
}

# Teste 4: Verificação de Logs de Segurança
Write-Host "Verificando logs de segurança..." -ForegroundColor Cyan
try {
    $logPath = "$targetUrl/wp-content/security-logs/auth.log"
    $logPathLocal = "./wp-content/security-logs/auth.log"
    $logFound = $false
    $logContent = ""
    
    # Tenta verificar logs localmente primeiro
    if (Test-Path $logPathLocal) {
        $logContent = Get-Content -Path $logPathLocal -Raw
        $logFound = $true
    } else {
        # Tenta acessar o log via HTTP (normalmente não seria acessível, mas testamos mesmo assim)
        try {
            $response = Invoke-WebRequest -Uri $logPath -UseBasicParsing -ErrorAction SilentlyContinue
            if ($response.StatusCode -eq 200) {
                $logContent = $response.Content
                $logFound = $true
                Write-AuthResult "Segurança de Logs" "FALHA" "O arquivo de log está acessível publicamente via HTTP! Isso é uma vulnerabilidade crítica."
            }
        } catch {
            # Esperado - o arquivo de log não deve ser acessível via HTTP
        }
    }
        if ($logFound) {
        $hasLoginAttempts = $logContent -match "Login attempt|Authentication|login"
        $hasSecurityHeaders = $logContent -match "Security headers"
        $hasFailedLogins = $logContent -match "FAILED|FALHA|failed|falha"
        $hasSuccessfulLogins = $logContent -match "SUCCESS|SUCESSO|success|sucesso"
        
        $details = ""
        if ($hasLoginAttempts) {
            $details += "Log contém registros de tentativas de login.`n"
        }
        if ($hasSecurityHeaders) {
            $details += "Log contém registros de aplicação de headers de segurança.`n"
        }
        if ($hasFailedLogins) {
            $details += "Log contém registros de logins falhos.`n"
        }
        if ($hasSuccessfulLogins) {
            $details += "Log contém registros de logins bem-sucedidos.`n"
        }
        
        # Verifica se o log tem entradas recentes (últimas 24 horas)
        $recentEntries = $logContent -match (Get-Date).ToString("yyyy-MM-dd")
        if ($recentEntries) {
            $details += "Log contém entradas recentes (hoje).`n"
        }
        
        if ($hasLoginAttempts -and $hasFailedLogins -and $hasSuccessfulLogins) {
            Write-AuthResult "Logs de Segurança" "SUCESSO" "Logs de segurança completos encontrados.`n$details"
        } elseif ($hasLoginAttempts) {
            Write-AuthResult "Logs de Segurança" "ALERTA" "Logs de segurança encontrados, mas podem estar incompletos.`n$details"
        } else {
            Write-AuthResult "Logs de Segurança" "FALHA" "Logs de segurança encontrados, mas não contêm informações de autenticação.`n$details"
        }
    } else {
        Write-AuthResult "Logs de Segurança" "FALHA" "Não foi possível encontrar logs de segurança."
    }
} catch {
    Write-AuthResult "Logs de Segurança" "ERRO" "Falha ao verificar logs de segurança: $_"
}

# Resumo dos testes de autenticação
Write-Host "\nGerando resumo dos testes de autenticação..." -ForegroundColor Yellow

try {
    $authResults = Get-Content -Path $authReportFile -Raw
    
    # Conta os resultados por status
    $successCount = ([regex]::Matches($authResults, "Status: SUCESSO")).Count
    $alertCount = ([regex]::Matches($authResults, "Status: ALERTA")).Count
    $failCount = ([regex]::Matches($authResults, "Status: FALHA")).Count
    $errorCount = ([regex]::Matches($authResults, "Status: ERRO")).Count
    $totalTests = $successCount + $alertCount + $failCount + $errorCount
    
    # Calcula porcentagem de sucesso
    $successPercentage = 0
    if ($totalTests -gt 0) {
        $successPercentage = [math]::Round(($successCount / $totalTests) * 100, 2)
    }
    
    # Adiciona resumo ao relatório
    "\n## Resumo dos Testes de Autenticação e Autorização" | Add-Content -Path $authReportFile
    "Total de testes: $totalTests" | Add-Content -Path $authReportFile
    "Sucessos: $successCount" | Add-Content -Path $authReportFile
    "Alertas: $alertCount" | Add-Content -Path $authReportFile
    "Falhas: $failCount" | Add-Content -Path $authReportFile
    "Erros: $errorCount" | Add-Content -Path $authReportFile
    "Taxa de sucesso: $successPercentage%" | Add-Content -Path $authReportFile
    
    # Exibe resumo no console
    Write-Host "\nResumo dos Testes de Autenticação e Autorização" -ForegroundColor Cyan
    Write-Host "Total de testes: $totalTests" -ForegroundColor White
    Write-Host "Sucessos: $successCount" -ForegroundColor Green
    Write-Host "Alertas: $alertCount" -ForegroundColor Yellow
    Write-Host "Falhas: $failCount" -ForegroundColor Red
    Write-Host "Erros: $errorCount" -ForegroundColor Magenta
    Write-Host "Taxa de sucesso: $successPercentage%" -ForegroundColor Cyan
} catch {
    Write-Host "Erro ao gerar resumo dos testes: $_" -ForegroundColor Red
}

# Finaliza o relatório e exibe mensagem de conclusão
Write-Host "\nTestes de autenticação e autorização concluídos!" -ForegroundColor Green
Write-Host "Relatório salvo em: $authReportFile" -ForegroundColor Cyan

# Encerra o ZAP
Write-Host "\nEncerrando OWASP ZAP..." -ForegroundColor Yellow
try {
    Invoke-WebRequest -Uri "http://localhost:8090/JSON/core/action/shutdown/" -UseBasicParsing | Out-Null
    Write-Host "OWASP ZAP encerrado com sucesso." -ForegroundColor Green
} catch {
    Write-Host "Erro ao encerrar OWASP ZAP: $_" -ForegroundColor Red
}

# Exibe caminho do relatório final
Write-Host "\nTestes de penetração concluídos!" -ForegroundColor Green
Write-Host "Relatório de autenticação salvo em: $authReportFile" -ForegroundColor Cyan

# 3. Testes específicos

# 3.1 XSS (Cross-Site Scripting)
Run-SecurityTest "XSS Scan" "curl -s 'http://localhost:8090/JSON/pscan/action/enableScanners/?ids=40012,40014,40016,40017' > $reportPath\xss-config.json"

# 3.2 SQL Injection
Run-SecurityTest "SQL Injection Scan" "curl -s 'http://localhost:8090/JSON/pscan/action/enableScanners/?ids=40018,40019,40020,40021,40022' > $reportPath\sqli-config.json"

# 3.3 CSRF (Cross-Site Request Forgery)
Run-SecurityTest "CSRF Scan" "curl -s 'http://localhost:8090/JSON/pscan/action/enableScanners/?ids=40012,40014' > $reportPath\csrf-config.json"

# 3.4 Testes de autenticação
Run-SecurityTest "Authentication Tests" "curl -s 'http://localhost:8090/JSON/pscan/action/enableScanners/?ids=10000,10001,10002' > $reportPath\auth-config.json"

# Gera relatório HTML
Write-Host "Gerando relatório HTML..." -ForegroundColor Yellow
curl -s "http://localhost:8090/OTHER/core/other/htmlreport/?" -o "$reportPath\zap-report.html"

# Gera relatório JSON para integração
Write-Host "Gerando relatório JSON..." -ForegroundColor Yellow
curl -s "http://localhost:8090/OTHER/core/other/jsonreport/?" -o "$reportPath\zap-report.json"

# Encerra o ZAP
Write-Host "Encerrando OWASP ZAP..." -ForegroundColor Yellow
curl -s "http://localhost:8090/JSON/core/action/shutdown/"

# Analisa resultados e gera resumo
Write-Host "Analisando resultados..." -ForegroundColor Cyan
$jsonReport = Get-Content "$reportPath\zap-report.json" | ConvertFrom-Json

$highAlerts = ($jsonReport.site.alerts | Where-Object { $_.riskcode -eq 3 }).Count
$mediumAlerts = ($jsonReport.site.alerts | Where-Object { $_.riskcode -eq 2 }).Count
$lowAlerts = ($jsonReport.site.alerts | Where-Object { $_.riskcode -eq 1 }).Count
$infoAlerts = ($jsonReport.site.alerts | Where-Object { $_.riskcode -eq 0 }).Count

# Gera relatório resumido
$summary = @"
# Relatório de Testes de Penetração - Açucaradas Encomendas

## Resumo de Vulnerabilidades

- **Críticas**: $highAlerts
- **Médias**: $mediumAlerts
- **Baixas**: $lowAlerts
- **Informativas**: $infoAlerts

## Detalhes

O relatório completo está disponível em:
- HTML: $reportPath\zap-report.html
- JSON: $reportPath\zap-report.json

## Próximos Passos

1. Revisar e corrigir vulnerabilidades críticas imediatamente
2. Planejar correções para vulnerabilidades médias
3. Documentar e monitorar vulnerabilidades de baixa prioridade
"@

$summary | Out-File -FilePath "$reportPath\pentest-summary.md" -Encoding utf8

# Resumo dos testes de autenticação
$authResults = Get-Content -Path $authReportFile | Select-String -Pattern "Status: (SUCESSO|FALHA|ALERTA|ERRO)"
$authSuccessCount = ($authResults | Where-Object { $_ -match "Status: SUCESSO" }).Count
$authFailCount = ($authResults | Where-Object { $_ -match "Status: FALHA" }).Count
$authAlertCount = ($authResults | Where-Object { $_ -match "Status: ALERTA" }).Count
$authErrorCount = ($authResults | Where-Object { $_ -match "Status: ERRO" }).Count
$authTotalTests = $authSuccessCount + $authFailCount + $authAlertCount + $authErrorCount

$authSummary = "`n## Resumo dos Testes de Autenticação`n"
$authSummary += "Total de testes: $authTotalTests`n"
$authSummary += "Sucesso: $authSuccessCount`n"
$authSummary += "Falhas: $authFailCount`n"
$authSummary += "Alertas: $authAlertCount`n"
$authSummary += "Erros: $authErrorCount`n"

if ($authTotalTests -gt 0) {
    $authSummary += "`nPorcentagem de sucesso: $([math]::Round(($authSuccessCount / $authTotalTests) * 100, 2))%`n"
}

Add-Content -Path $authReportFile -Value $authSummary

# Para o ZAP
Stop-Process -Name java -Force -ErrorAction SilentlyContinue

Write-Host "Testes de penetração concluídos. Relatório disponível em $reportPath\pentest-summary.md" -ForegroundColor Green
Write-Host "Relatório de autenticação salvo em: $authReportFile" -ForegroundColor Green

# Instruções adicionais
Write-Host "
Para executar testes manuais adicionais, considere as seguintes ferramentas:" -ForegroundColor Yellow
Write-Host "1. Burp Suite - Para interceptação e manipulação de tráfego" -ForegroundColor Cyan
Write-Host "2. Nikto - Para varredura de vulnerabilidades em servidores web" -ForegroundColor Cyan
Write-Host "3. Metasploit - Para testes de exploração avançados" -ForegroundColor Cyan
Write-Host "4. MobSF - Para análise específica de aplicativos móveis" -ForegroundColor Cyan